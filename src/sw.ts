
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute, NavigationRoute } from 'workbox-routing';
import { NetworkFirst, CacheFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { ExpirationPlugin } from 'workbox-expiration';

declare const self: ServiceWorkerGlobalScope;

// Precache all static assets generated by Vite
precacheAndRoute(self.__WB_MANIFEST);

// Clean up outdated caches
cleanupOutdatedCaches();

// Cache names
const DATA_CACHE = 'lytotec-data-v1';
const API_CACHE = 'lytotec-api-v1';
const NAVIGATION_CACHE = 'lytotec-navigation-v1';
const LARGE_FILES_CACHE = 'lytotec-large-files-v1';

// Cache large JavaScript files with specific strategy
registerRoute(
  ({ url, request }) => 
    request.destination === 'script' && 
    url.pathname.includes('/assets/') && 
    url.pathname.endsWith('.js'),
  new CacheFirst({
    cacheName: LARGE_FILES_CACHE,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24 * 7, // 7 days
        purgeOnQuotaError: true,
      }),
    ],
  })
);

// Cache API calls with Network First strategy - Dynamic Supabase URL
registerRoute(
  ({ url }) => {
    const supabasePattern = /^https:\/\/[a-z]+\.supabase\.co/;
    return supabasePattern.test(url.origin) && url.pathname.startsWith('/rest/v1/');
  },
  new NetworkFirst({
    cacheName: API_CACHE,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 300,
        maxAgeSeconds: 60 * 60 * 12, // 12 hours - reduced
        purgeOnQuotaError: true,
      }),
    ],
  })
);

// Cache authentication requests - Dynamic Supabase URL
registerRoute(
  ({ url }) => {
    const supabasePattern = /^https:\/\/[a-z]+\.supabase\.co/;
    return supabasePattern.test(url.origin) && url.pathname.startsWith('/auth/v1/');
  },
  new NetworkFirst({
    cacheName: 'lytotec-auth-v1',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 60 * 15, // 15 minutes - reduced
      }),
    ],
  })
);

// Cache static assets with Cache First strategy
registerRoute(
  ({ request }) => request.destination === 'image' || 
                   request.destination === 'font' ||
                   request.destination === 'style',
  new CacheFirst({
    cacheName: 'lytotec-assets-v1',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 200,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
);

// Cache Google Fonts with Stale While Revalidate
registerRoute(
  ({ url }) => url.origin === 'https://fonts.googleapis.com' || url.origin === 'https://fonts.gstatic.com',
  new StaleWhileRevalidate({
    cacheName: 'lytotec-fonts-v1',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  })
);

// Navigation route with offline fallback
const navigationRoute = new NavigationRoute(
  new NetworkFirst({
    cacheName: NAVIGATION_CACHE,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  }),
  {
    allowlist: [/^\/$/],
    denylist: [/^\/_/, /\/[^/?]+\.[^/]+$/],
  }
);

registerRoute(navigationRoute);

// Handle offline data storage
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'CACHE_DATA') {
    event.waitUntil(cacheOfflineData(event.data.key, event.data.data));
  }
  
  if (event.data && event.data.type === 'GET_CACHED_DATA') {
    event.waitUntil(getCachedData(event.data.key).then(data => {
      event.ports[0].postMessage({ data });
    }));
  }
  
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Cache offline data
async function cacheOfflineData(key: string, data: any) {
  try {
    const cache = await caches.open(DATA_CACHE);
    const response = new Response(JSON.stringify(data), {
      headers: { 'Content-Type': 'application/json' }
    });
    await cache.put(new Request(`/offline-data/${key}`), response);
    console.log(`💾 Cached data for key: ${key}`);
  } catch (error) {
    console.error('Error caching offline data:', error);
  }
}

// Retrieve cached data
async function getCachedData(key: string) {
  try {
    const cache = await caches.open(DATA_CACHE);
    const response = await cache.match(`/offline-data/${key}`);
    if (response) {
      const data = await response.json();
      console.log(`📖 Retrieved cached data for key: ${key}`);
      return data;
    }
    return null;
  } catch (error) {
    console.error('Error retrieving cached data:', error);
    return null;
  }
}

// Background sync for offline actions
self.addEventListener('sync', (event) => {
  console.log('🔄 Background sync triggered:', event.tag);
  
  if (event.tag === 'sync-offline-data') {
    event.waitUntil(syncOfflineData());
  }
});

// Sync offline data when connection is restored
async function syncOfflineData() {
  try {
    // Get offline data from localStorage via message
    const clients = await self.clients.matchAll();
    if (clients.length > 0) {
      clients[0].postMessage({ type: 'SYNC_OFFLINE_DATA' });
    }
  } catch (error) {
    console.error('Error syncing offline data:', error);
  }
}

// Install event
self.addEventListener('install', (event) => {
  console.log('🚀 Service Worker installing...');
  self.skipWaiting();
});

// Activate event
self.addEventListener('activate', (event) => {
  console.log('✅ Service Worker activated');
  event.waitUntil(self.clients.claim());
});

// Handle fetch events with offline fallbacks
self.addEventListener('fetch', (event) => {
  // Skip non-GET requests
  if (event.request.method !== 'GET') {
    return;
  }

  // Handle navigation requests
  if (event.request.mode === 'navigate') {
    event.respondWith(
      fetch(event.request).catch(() => {
        return caches.match('/') || caches.match('/offline.html');
      })
    );
    return;
  }

  // Handle API requests - Dynamic pattern
  const supabasePattern = /\.supabase\.co\/rest\/v1\//;
  if (supabasePattern.test(event.request.url)) {
    event.respondWith(
      fetch(event.request).catch(async () => {
        const cachedResponse = await caches.match(event.request);
        if (cachedResponse) {
          console.log('📱 Serving cached API data:', event.request.url);
          return cachedResponse;
        }
        
        // Return empty array for list endpoints when offline
        if (event.request.url.includes('select=')) {
          return new Response(JSON.stringify([]), {
            headers: { 'Content-Type': 'application/json' }
          });
        }
        
        throw new Error('No cached data available');
      })
    );
  }
});

console.log('🏗️ Service Worker loaded and ready');
